{"ast":null,"code":"(function (root, factory) {\n  if (typeof exports === 'object') {\n    module.exports = factory(require('moment'));\n  } else if (typeof define === 'function' && define.amd) {\n    define('moment-range', ['moment'], factory);\n  } else {\n    root.moment = factory(root.moment);\n  }\n})(this, function (moment) {\n  var DateRange, INTERVALS;\n  INTERVALS = {\n    year: true,\n    month: true,\n    week: true,\n    day: true,\n    hour: true,\n    minute: true,\n    second: true\n  };\n  /**\n    * DateRange class to store ranges and query dates.\n    * @typedef {!Object}\n  *\n  */\n\n  DateRange = function () {\n    /**\n      * DateRange instance.\n      * @param {(Moment|Date)} start Start of interval.\n      * @param {(Moment|Date)} end   End of interval.\n      * @constructor\n    *\n    */\n    function DateRange(start, end) {\n      this.start = moment(start);\n      this.end = moment(end);\n    }\n    /**\n      * Determine if the current interval contains a given moment/date/range.\n      * @param {(Moment|Date|DateRange)} other Date to check.\n      * @return {!boolean}\n    *\n    */\n\n\n    DateRange.prototype.contains = function (other) {\n      if (other instanceof DateRange) {\n        return this.start <= other.start && this.end >= other.end;\n      } else {\n        return this.start <= other && other <= this.end;\n      }\n    };\n    /**\n      * @private\n    *\n    */\n\n\n    DateRange.prototype._by_string = function (interval, hollaback) {\n      var current, _results;\n\n      current = moment(this.start);\n      _results = [];\n\n      while (this.contains(current)) {\n        hollaback.call(this, current.clone());\n\n        _results.push(current.add(interval, 1));\n      }\n\n      return _results;\n    };\n    /**\n      * @private\n    *\n    */\n\n\n    DateRange.prototype._by_range = function (range_interval, hollaback) {\n      var i, l, _i, _results;\n\n      l = Math.round(this / range_interval);\n\n      if (l === Infinity) {\n        return this;\n      }\n\n      _results = [];\n\n      for (i = _i = 0; 0 <= l ? _i <= l : _i >= l; i = 0 <= l ? ++_i : --_i) {\n        _results.push(hollaback.call(this, moment(this.start.valueOf() + range_interval.valueOf() * i)));\n      }\n\n      return _results;\n    };\n    /**\n      * Determine if the current date range overlaps a given date range.\n      * @param {!DateRange} range Date range to check.\n      * @return {!boolean}\n    *\n    */\n\n\n    DateRange.prototype.overlaps = function (range) {\n      return this.intersect(range) !== null;\n    };\n    /**\n      * Determine the intersecting periods from one or more date ranges.\n      * @param {!DateRange} other A date range to intersect with this one.\n      * @return {!DateRange|null}\n    *\n    */\n\n\n    DateRange.prototype.intersect = function (other) {\n      var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;\n\n      if (this.start <= (_ref1 = other.start) && _ref1 < (_ref = this.end) && _ref < other.end) {\n        return new DateRange(other.start, this.end);\n      } else if (other.start < (_ref3 = this.start) && _ref3 < (_ref2 = other.end) && _ref2 <= this.end) {\n        return new DateRange(this.start, other.end);\n      } else if (other.start < (_ref5 = this.start) && _ref5 < (_ref4 = this.end) && _ref4 < other.end) {\n        return this;\n      } else if (this.start <= (_ref7 = other.start) && _ref7 < (_ref6 = other.end) && _ref6 <= this.end) {\n        return other;\n      } else {\n        return null;\n      }\n    };\n    /**\n      * Subtract one range from another.\n      * @param {!DateRange} other A date range to substract from this one.\n      * @return {!DateRange[]}\n    *\n    */\n\n\n    DateRange.prototype.subtract = function (other) {\n      var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;\n\n      if (this.intersect(other) === null) {\n        return [this];\n      } else if (other.start <= (_ref1 = this.start) && _ref1 < (_ref = this.end) && _ref <= other.end) {\n        return [];\n      } else if (other.start <= (_ref3 = this.start) && _ref3 < (_ref2 = other.end) && _ref2 < this.end) {\n        return [new DateRange(other.end, this.end)];\n      } else if (this.start < (_ref5 = other.start) && _ref5 < (_ref4 = this.end) && _ref4 <= other.end) {\n        return [new DateRange(this.start, other.start)];\n      } else if (this.start < (_ref7 = other.start) && _ref7 < (_ref6 = other.end) && _ref6 < this.end) {\n        return [new DateRange(this.start, other.start), new DateRange(other.end, this.end)];\n      }\n    };\n    /**\n      * Iterate over the date range by a given date range, executing a function\n      * for each sub-range.\n      * @param {!DateRange|String} range     Date range to be used for iteration\n      *                                      or shorthand string (shorthands:\n      *                                      http://momentjs.com/docs/#/manipulating/add/)\n      * @param {!function(Moment)} hollaback Function to execute for each sub-range.\n      * @return {!boolean}\n    *\n    */\n\n\n    DateRange.prototype.by = function (range, hollaback) {\n      if (typeof range === 'string') {\n        this._by_string(range, hollaback);\n      } else {\n        this._by_range(range, hollaback);\n      }\n\n      return this;\n    };\n    /**\n      * Date range in milliseconds. Allows basic coercion math of date ranges.\n      * @return {!number}\n    *\n    */\n\n\n    DateRange.prototype.valueOf = function () {\n      return this.end - this.start;\n    };\n    /**\n      * Date range toDate\n      * @return  {!Array}\n    *\n    */\n\n\n    DateRange.prototype.toDate = function () {\n      return [this.start.toDate(), this.end.toDate()];\n    };\n    /**\n      * Determine if this date range is the same as another.\n      * @param {!DateRange} other Another date range to compare to.\n      * @return {!boolean}\n    *\n    */\n\n\n    DateRange.prototype.isSame = function (other) {\n      return this.start.isSame(other.start) && this.end.isSame(other.end);\n    };\n    /**\n      * Return the difference of the end vs start.\n      *   - To get the difference in milliseconds, use range#diff\n      *   - To get the difference in another unit of measurement, pass that measurement as the second argument.\n      * @return milliseconds if no measure is passed in, otherwise an increment of measure\n    *\n    */\n\n\n    DateRange.prototype.diff = function (unit) {\n      if (unit == null) {\n        unit = void 0;\n      }\n\n      return this.end.diff(this.start, unit);\n    };\n\n    return DateRange;\n  }();\n  /**\n    * Build a date range.\n    * @param {(Moment|Date)} start Start of range.\n    * @param {(Moment|Date)} end   End of range.\n    * @this {Moment}\n    * @return {!DateRange}\n  *\n  */\n\n\n  moment.fn.range = function (start, end) {\n    if (start in INTERVALS) {\n      return new DateRange(moment(this).startOf(start), moment(this).endOf(start));\n    } else {\n      return new DateRange(start, end);\n    }\n  };\n  /**\n    * Build a date range.\n    * @param {(Moment|Date)} start Start of range.\n    * @param {(Moment|Date)} end   End of range.\n    * @this {Moment}\n    * @return {!DateRange}\n  *\n  */\n\n\n  moment.range = function (start, end) {\n    return new DateRange(start, end);\n  };\n  /**\n    * Check if the current moment is within a given date range.\n    * @param {!DateRange} range Date range to check.\n    * @this {Moment}\n    * @return {!boolean}\n  *\n  */\n\n\n  moment.fn.within = function (range) {\n    return range.contains(this._d);\n  };\n\n  return moment;\n});","map":null,"metadata":{},"sourceType":"script"}