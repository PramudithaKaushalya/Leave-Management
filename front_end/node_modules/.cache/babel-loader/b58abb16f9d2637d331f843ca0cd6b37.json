{"ast":null,"code":"'use strict';\n\nvar _get = require('babel-runtime/helpers/get')['default'];\n\nvar _inherits = require('babel-runtime/helpers/inherits')['default'];\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar SmartSticky = function (_Component) {\n  _inherits(SmartSticky, _Component);\n\n  _createClass(SmartSticky, null, [{\n    key: 'propTypes',\n    value: {\n      tolerance: _react.PropTypes.number,\n      children: _react.PropTypes.node\n    },\n    enumerable: true\n  }, {\n    key: 'defaultProps',\n    value: {\n      tolerance: 50 // ammount of scrolled pixels before sticky will start to move\n\n    },\n    enumerable: true\n  }]);\n\n  function SmartSticky(props) {\n    _classCallCheck(this, SmartSticky);\n\n    _get(Object.getPrototypeOf(SmartSticky.prototype), 'constructor', this).call(this, props);\n\n    this.scrollInfo = {\n      currentMove: 0,\n      // ammount of pixels scrolled since last direction change\n      lastScrollPosition: 0,\n      // scroll position of previous scroll event\n      lastScrollChange: 0 // difference between current event scroll position and previous one\n\n    };\n    this.state = {\n      stickyPosition: 0\n    };\n  }\n\n  _createClass(SmartSticky, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      // in case of server side rendering - let's attach events\n      // after element is mounted in DOM (it'll not happen on server side render)\n      this.handler = this._handleScroll.bind(this);\n      window.addEventListener('scroll', this.handler);\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      // to avoid memory leak - remove event listener when element is unmounted\n      window.removeEventListener('scroll', this.handler);\n    }\n  }, {\n    key: '_handleScroll',\n    value: function _handleScroll() {\n      this._updateLastScrollChange();\n\n      this._updateCurrentMove();\n\n      this._updateStickyPosition();\n\n      this._updateLastScrollPosition();\n    }\n    /**\n     * Sets number of pixels scrolled by current scroll event\n     * @return {void}\n     */\n\n  }, {\n    key: '_updateLastScrollChange',\n    value: function _updateLastScrollChange() {\n      var lastScrollPosition = this.scrollInfo.lastScrollPosition;\n      this.scrollInfo.lastScrollChange = window.scrollY - lastScrollPosition;\n    }\n    /**\n     * Set's total ammount of pixels scrolled since last change of scrolling direction\n     * If direction change is detected - it'll reset this ammount\n     * @return {void}\n     */\n\n  }, {\n    key: '_updateCurrentMove',\n    value: function _updateCurrentMove() {\n      if (this._hasChangedDirection()) {\n        this.scrollInfo.currentMove = 0;\n      } else {\n        var currentMove = this.scrollInfo.currentMove;\n        this.scrollInfo.currentMove = currentMove + this._getScrollDifference();\n      }\n    }\n    /**\n     * Basing on all informations we've got, it'll update sticky bar position\n     * @return {void}\n     */\n\n  }, {\n    key: '_updateStickyPosition',\n    value: function _updateStickyPosition() {\n      var stickyPosition = this.state.stickyPosition;\n      var _scrollInfo = this.scrollInfo;\n      var currentMove = _scrollInfo.currentMove;\n      var lastScrollChange = _scrollInfo.lastScrollChange;\n      var targetDivHeight = this.refs.containerDiv.clientHeight;\n      var tolerance = this.props.tolerance; // if move in one direction is smaller then tolerance\n\n      if (Math.abs(currentMove) < tolerance) {\n        // and sticky is not in the middle of movement (halfly hidden)\n        // then do nothing\n        if (stickyPosition === 0 || stickyPosition === targetDivHeight) return;\n      } // add change of scroll position to sticky position\n\n\n      var newStickyPosition = stickyPosition + lastScrollChange; // if change is bigger than sticky height - cap it (it cannot be 'more' hidden)\n\n      if (newStickyPosition > targetDivHeight) newStickyPosition = targetDivHeight; // if sticky is fully visible - don't let it go down the screen\n\n      if (newStickyPosition < 0) newStickyPosition = 0; // we set sticky position as state so element will get re-rendered\n\n      this.setState({\n        stickyPosition: newStickyPosition\n      });\n    }\n    /**\n     * Save current scroll position so it can be used later as previous\n     * scroll position\n     * @return {void}\n     */\n\n  }, {\n    key: '_updateLastScrollPosition',\n    value: function _updateLastScrollPosition() {\n      this.scrollInfo.lastScrollPosition = window.scrollY;\n    }\n    /**\n     * Returns pixels scrolled comparing to last scroll event\n     * @return {int}\n     */\n\n  }, {\n    key: '_getScrollDifference',\n    value: function _getScrollDifference() {\n      var lastScrollPosition = this.scrollInfo.lastScrollPosition;\n      return window.scrollY - lastScrollPosition;\n    }\n    /**\n     * Returns if current scroll event is in different direction to previous\n     * @return {Boolean}\n     */\n\n  }, {\n    key: '_hasChangedDirection',\n    value: function _hasChangedDirection() {\n      var scrollDifference = this._getScrollDifference();\n\n      var currentMove = this.scrollInfo.currentMove;\n      return scrollDifference > 0 && currentMove < 0 || scrollDifference < 0 && currentMove > 0;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var children = this.props.children;\n      var stickyPosition = this.state.stickyPosition;\n      var style = {\n        position: 'fixed',\n        top: -stickyPosition,\n        left: 0,\n        right: 0,\n        zIndex: 1000\n      };\n      return _react2['default'].createElement('div', {\n        ref: 'containerDiv',\n        style: style\n      }, children);\n    }\n  }]);\n\n  return SmartSticky;\n}(_react.Component);\n\nexports['default'] = SmartSticky;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}